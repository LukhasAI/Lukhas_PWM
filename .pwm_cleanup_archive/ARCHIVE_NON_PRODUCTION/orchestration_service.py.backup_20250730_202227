"""
LUKHAS Orchestration Service - Module API Interface

This service provides orchestration and coordination between different modules.
All operations are logged via Î›TRACE and respect user consent and tier access.

Key functions:
- coordinate_modules: Coordinate actions across multiple modules
- workflow_execution: Execute complex workflows involving multiple modules
- resource_management: Manage computational resources across modules
- event_routing: Route events between modules
- performance_orchestration: Integrate performance monitoring and optimization (TODO #8)

Integration with lukhas-id:
- Orchestration requires valid user identity and consent
- All coordination activities are logged for transparency and audit
- Tier-based access to different orchestration capabilities
- Cross-module permission validation

Performance Integration:
- Performance monitoring integration via PerformanceOrchestrator
- Real-time performance optimization during workflow execution
- Compliance-aware resource allocation
- Comprehensive performance analytics
"""

import os
import sys
import time
from typing import Dict, Any, Optional, List, Union
from datetime import datetime
import asyncio
import json

# Add parent directory to path for identity interface
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

# Import message bus for cross-module communication
message_bus_available = True
try:
    from bridge.message_bus import (
        MessageBus, Message, MessageType, MessagePriority,
        send_command, send_query, send_event
    )
except ImportError:
    message_bus_available = False
    print("âš ï¸ Message bus not available - using basic communication fallbacks")

# Import performance orchestrator for TODO #8 integration
performance_orchestrator_available = True
try:
    from core.performance.performance_orchestrator import (
        PerformanceOrchestrator, OptimizationStrategy, PerformanceStatus
    )
except ImportError:
    performance_orchestrator_available = False
    print("âš ï¸ Performance orchestrator not available - performance features disabled")

try:
    from identity.interface import IdentityClient
except ImportError:
    # Fallback for development
    class IdentityClient:
        def verify_user_access(self, user_id: str, required_tier: str = "LAMBDA_TIER_1") -> bool:
            return True
        def check_consent(self, user_id: str, action: str) -> bool:
            return True
        def log_activity(self, activity_type: str, user_id: str, metadata: Dict[str, Any]) -> None:
            print(f"ORCHESTRATION_LOG: {activity_type} by {user_id}: {metadata}")


class OrchestrationService:
    """
    Main orchestration service for the LUKHAS AGI system.
    
    Provides coordination and workflow management across modules with full
    integration to the identity system for access control and audit logging.
    """
    
    def __init__(self):
        """Initialize the orchestration service with identity integration."""
        self.identity_client = IdentityClient()
        
        # Initialize message bus for cross-module communication
        if message_bus_available:
            self.message_bus = MessageBus()
            self.communication_enabled = True
        else:
            self.message_bus = None
            self.communication_enabled = False
            
        # Initialize performance orchestrator for TODO #8 integration
        if performance_orchestrator_available:
            self.performance_orchestrator = PerformanceOrchestrator()
            self.performance_enabled = True
        else:
            self.performance_orchestrator = None
            self.performance_enabled = False
            
        self.orchestration_capabilities = {
            "basic_coordination": {"min_tier": "LAMBDA_TIER_2", "consent": "orchestration_basic"},
            "workflow_execution": {"min_tier": "LAMBDA_TIER_3", "consent": "orchestration_workflow"},
            "resource_management": {"min_tier": "LAMBDA_TIER_3", "consent": "orchestration_resources"},
            "cross_module_events": {"min_tier": "LAMBDA_TIER_4", "consent": "orchestration_events"},
            "system_coordination": {"min_tier": "LAMBDA_TIER_4", "consent": "orchestration_system"},
            "message_routing": {"min_tier": "LAMBDA_TIER_2", "consent": "orchestration_messaging"},
            # TODO #8: Performance orchestration capabilities
            "performance_monitoring": {"min_tier": "LAMBDA_TIER_2", "consent": "performance_monitoring"},
            "performance_optimization": {"min_tier": "LAMBDA_TIER_3", "consent": "performance_optimization"},
            "system_tuning": {"min_tier": "LAMBDA_TIER_4", "consent": "system_optimization"}
        }
        self.active_workflows = {}
        self.module_status = {
            "ethics": {"status": "available", "load": 0.0},
            "memory": {"status": "available", "load": 0.0},
            "creativity": {"status": "available", "load": 0.0},
            "consciousness": {"status": "available", "load": 0.0},
            "learning": {"status": "available", "load": 0.0},
            "quantum": {"status": "available", "load": 0.0},
            "orchestration": {"status": "available", "load": 0.0},
            "symbolic_tools": {"status": "available", "load": 0.0}
        }
        self.event_queue = []
        
    async def start_orchestration(self):
        """Start the orchestration service and message bus."""
        if self.message_bus:
            await self.message_bus.start()
            # Register orchestration module
            success = self.message_bus.register_module("orchestration", "system")
            if success:
                print("ðŸš€ Orchestration service started with message bus integration")
            else:
                print("âš ï¸ Orchestration service started but message bus registration failed")
        else:
            print("ðŸš€ Orchestration service started (no message bus)")
        
    def coordinate_modules(self, user_id: str, coordination_request: Dict[str, Any],
                          coordination_type: str = "sequential") -> Dict[str, Any]:
        """
        Coordinate actions across multiple modules.
        
        Args:
            user_id: The user requesting coordination
            coordination_request: Details of the coordination request
            coordination_type: Type of coordination (sequential, parallel, conditional)
            
        Returns:
            Dict: Coordination results and module responses
        """
        # Verify user access for module coordination
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_2"):
            return {"success": False, "error": "Insufficient tier for module coordination"}
        
        # Check consent for coordination
        if not self.identity_client.check_consent(user_id, "orchestration_basic"):
            return {"success": False, "error": "User consent required for module coordination"}
        
        try:
            # Process coordination request
            coordination_results = self._process_coordination(coordination_request, coordination_type)
            
            coordination_id = f"coord_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{user_id}"
            
            # Log coordination activity
            self.identity_client.log_activity("module_coordination_executed", user_id, {
                "coordination_id": coordination_id,
                "coordination_type": coordination_type,
                "modules_involved": coordination_request.get("modules", []),
                "coordination_success": coordination_results.get("success", False),
                "execution_time": coordination_results.get("execution_time", 0.0)
            })
            
            return {
                "success": True,
                "coordination_id": coordination_id,
                "coordination_results": coordination_results,
                "coordination_type": coordination_type,
                "executed_at": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            error_msg = f"Module coordination error: {str(e)}"
            self.identity_client.log_activity("coordination_error", user_id, {
                "coordination_type": coordination_type,
                "modules": coordination_request.get("modules", []),
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    def execute_workflow(self, user_id: str, workflow_definition: Dict[str, Any],
                        execution_mode: str = "standard") -> Dict[str, Any]:
        """
        Execute complex workflows involving multiple modules.
        
        Args:
            user_id: The user executing the workflow
            workflow_definition: Definition of the workflow to execute
            execution_mode: Mode of execution (standard, fast, thorough)
            
        Returns:
            Dict: Workflow execution results
        """
        # Verify user access for workflow execution
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_3"):
            return {"success": False, "error": "Insufficient tier for workflow execution"}
        
        # Check consent for workflow processing
        if not self.identity_client.check_consent(user_id, "orchestration_workflow"):
            return {"success": False, "error": "User consent required for workflow execution"}
        
        try:
            # Execute workflow
            workflow_results = self._execute_workflow_steps(workflow_definition, execution_mode)
            
            workflow_id = f"workflow_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{user_id}"
            
            # Store active workflow
            self.active_workflows[workflow_id] = {
                "user_id": user_id,
                "definition": workflow_definition,
                "execution_mode": execution_mode,
                "started_at": datetime.utcnow().isoformat(),
                "status": workflow_results.get("status", "unknown")
            }
            
            # Log workflow execution
            self.identity_client.log_activity("workflow_executed", user_id, {
                "workflow_id": workflow_id,
                "execution_mode": execution_mode,
                "steps_count": len(workflow_definition.get("steps", [])),
                "workflow_success": workflow_results.get("success", False),
                "total_execution_time": workflow_results.get("total_time", 0.0)
            })
            
            return {
                "success": True,
                "workflow_id": workflow_id,
                "workflow_results": workflow_results,
                "execution_mode": execution_mode,
                "executed_at": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            error_msg = f"Workflow execution error: {str(e)}"
            self.identity_client.log_activity("workflow_error", user_id, {
                "execution_mode": execution_mode,
                "steps_count": len(workflow_definition.get("steps", [])),
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    def manage_resources(self, user_id: str, resource_request: Dict[str, Any],
                        management_action: str = "allocate") -> Dict[str, Any]:
        """
        Manage computational resources across modules.
        
        Args:
            user_id: The user managing resources
            resource_request: Details of the resource request
            management_action: Action to perform (allocate, deallocate, optimize)
            
        Returns:
            Dict: Resource management results
        """
        # Verify user access for resource management
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_3"):
            return {"success": False, "error": "Insufficient tier for resource management"}
        
        # Check consent for resource management
        if not self.identity_client.check_consent(user_id, "orchestration_resources"):
            return {"success": False, "error": "User consent required for resource management"}
        
        try:
            # Process resource management
            resource_results = self._manage_module_resources(resource_request, management_action)
            
            resource_id = f"resource_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{user_id}"
            
            # Log resource management
            self.identity_client.log_activity("resource_management_executed", user_id, {
                "resource_id": resource_id,
                "management_action": management_action,
                "requested_modules": resource_request.get("modules", []),
                "resource_success": resource_results.get("success", False),
                "resources_allocated": resource_results.get("allocated_resources", {})
            })
            
            return {
                "success": True,
                "resource_id": resource_id,
                "resource_results": resource_results,
                "management_action": management_action,
                "managed_at": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            error_msg = f"Resource management error: {str(e)}"
            self.identity_client.log_activity("resource_management_error", user_id, {
                "management_action": management_action,
                "requested_modules": resource_request.get("modules", []),
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    def route_event(self, user_id: str, event_data: Dict[str, Any], 
                   routing_strategy: str = "broadcast") -> Dict[str, Any]:
        """
        Route events between modules.
        
        Args:
            user_id: The user routing the event
            event_data: Event data to route
            routing_strategy: Strategy for routing (broadcast, targeted, conditional)
            
        Returns:
            Dict: Event routing results
        """
        # Verify user access for event routing
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_4"):
            return {"success": False, "error": "Insufficient tier for event routing"}
        
        # Check consent for event routing
        if not self.identity_client.check_consent(user_id, "orchestration_events"):
            return {"success": False, "error": "User consent required for event routing"}
        
        try:
            # Route event
            routing_results = self._route_inter_module_event(event_data, routing_strategy)
            
            event_id = f"event_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{user_id}"
            
            # Add to event queue
            self.event_queue.append({
                "event_id": event_id,
                "user_id": user_id,
                "event_data": event_data,
                "routing_strategy": routing_strategy,
                "routed_at": datetime.utcnow().isoformat(),
                "status": routing_results.get("status", "pending")
            })
            
            # Log event routing
            self.identity_client.log_activity("event_routed", user_id, {
                "event_id": event_id,
                "routing_strategy": routing_strategy,
                "target_modules": routing_results.get("target_modules", []),
                "routing_success": routing_results.get("success", False),
                "delivery_count": routing_results.get("delivery_count", 0)
            })
            
            return {
                "success": True,
                "event_id": event_id,
                "routing_results": routing_results,
                "routing_strategy": routing_strategy,
                "routed_at": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            error_msg = f"Event routing error: {str(e)}"
            self.identity_client.log_activity("event_routing_error", user_id, {
                "routing_strategy": routing_strategy,
                "event_type": event_data.get("type", "unknown"),
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    async def send_inter_module_message(self, user_id: str, source_module: str, 
                                       target_module: str, message_type: str,
                                       payload: Dict[str, Any], 
                                       priority: str = "normal") -> Dict[str, Any]:
        """
        Send messages between modules using the message bus.
        
        Args:
            user_id: The user sending the message
            source_module: Module sending the message
            target_module: Module receiving the message  
            message_type: Type of message (command, query, event)
            payload: Message payload
            priority: Message priority (low, normal, high, critical)
            
        Returns:
            Dict: Message sending results
        """
        # Verify user access for messaging
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_2"):
            return {"success": False, "error": "Insufficient tier for inter-module messaging"}
        
        # Check consent for messaging
        if not self.identity_client.check_consent(user_id, "orchestration_messaging"):
            return {"success": False, "error": "User consent required for inter-module messaging"}
        
        if not self.communication_enabled or not self.message_bus:
            return {"success": False, "error": "Message bus not available"}
        
        try:
            # Map string types to enums
            msg_type_map = {
                "command": MessageType.COMMAND,
                "query": MessageType.QUERY, 
                "event": MessageType.EVENT,
                "response": MessageType.RESPONSE
            }
            
            priority_map = {
                "low": MessagePriority.LOW,
                "normal": MessagePriority.NORMAL,
                "high": MessagePriority.HIGH,
                "critical": MessagePriority.CRITICAL,
                "emergency": MessagePriority.EMERGENCY
            }
            
            message = Message(
                id=f"msg_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{user_id}",
                type=msg_type_map.get(message_type, MessageType.EVENT),
                source_module=source_module,
                target_module=target_module,
                priority=priority_map.get(priority, MessagePriority.NORMAL),
                payload=payload,
                user_id=user_id,
                response_required=message_type in ["command", "query"]
            )
            
            success = await self.message_bus.send_message(message)
            
            # Log message activity
            self.identity_client.log_activity("inter_module_message_sent", user_id, {
                "message_id": message.id,
                "source_module": source_module,
                "target_module": target_module,
                "message_type": message_type,
                "priority": priority,
                "success": success
            })
            
            return {
                "success": success,
                "message_id": message.id,
                "source_module": source_module,
                "target_module": target_module,
                "sent_at": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            error_msg = f"Inter-module message error: {str(e)}"
            self.identity_client.log_activity("inter_module_message_error", user_id, {
                "source_module": source_module,
                "target_module": target_module,
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    async def receive_module_messages(self, user_id: str, module_name: str,
                                    timeout: Optional[float] = 5.0) -> Dict[str, Any]:
        """
        Receive messages for a specific module.
        
        Args:
            user_id: The user receiving messages
            module_name: Module to receive messages for
            timeout: Timeout for message reception
            
        Returns:
            Dict: Received messages or timeout result
        """
        # Verify user access
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_2"):
            return {"success": False, "error": "Insufficient tier for message reception"}
        
        if not self.communication_enabled or not self.message_bus:
            return {"success": False, "error": "Message bus not available"}
        
        try:
            message = await self.message_bus.receive_message(module_name, timeout)
            
            if message:
                # Log message reception
                self.identity_client.log_activity("module_message_received", user_id, {
                    "message_id": message.id,
                    "module_name": module_name,
                    "source_module": message.source_module,
                    "message_type": message.type.value
                })
                
                return {
                    "success": True,
                    "message": {
                        "id": message.id,
                        "type": message.type.value,
                        "source_module": message.source_module,
                        "priority": message.priority.value,
                        "payload": message.payload,
                        "timestamp": message.timestamp,
                        "user_id": message.user_id
                    },
                    "received_at": datetime.utcnow().isoformat()
                }
            else:
                return {
                    "success": True,
                    "message": None,
                    "timeout": True,
                    "checked_at": datetime.utcnow().isoformat()
                }
                
        except Exception as e:
            error_msg = f"Message reception error: {str(e)}"
            self.identity_client.log_activity("message_reception_error", user_id, {
                "module_name": module_name,
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    async def broadcast_system_event(self, user_id: str, event_type: str,
                                   event_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Broadcast system-wide events to all modules.
        
        Args:
            user_id: The user broadcasting the event
            event_type: Type of event to broadcast
            event_data: Event data to broadcast
            
        Returns:
            Dict: Broadcast results
        """
        # Verify user access for system events
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_4"):
            return {"success": False, "error": "Insufficient tier for system event broadcasting"}
        
        # Check consent for system events
        if not self.identity_client.check_consent(user_id, "orchestration_events"):
            return {"success": False, "error": "User consent required for system event broadcasting"}
        
        if not self.communication_enabled or not self.message_bus:
            return {"success": False, "error": "Message bus not available"}
        
        try:
            broadcast_results = []
            event_id = f"event_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{user_id}"
            
            # Send to all active modules
            for module_name in self.module_status.keys():
                if module_name != "orchestration":  # Don't send to self
                    message = Message(
                        id=f"{event_id}_{module_name}",
                        type=MessageType.EVENT,
                        source_module="orchestration",
                        target_module=module_name,
                        priority=MessagePriority.HIGH,
                        payload={
                            "event_type": event_type,
                            "event_data": event_data,
                            "event_id": event_id
                        },
                        user_id=user_id
                    )
                    
                    success = await self.message_bus.send_message(message)
                    broadcast_results.append({
                        "module": module_name,
                        "success": success,
                        "message_id": message.id
                    })
            
            # Log broadcast activity
            self.identity_client.log_activity("system_event_broadcast", user_id, {
                "event_id": event_id,
                "event_type": event_type,
                "target_modules": list(self.module_status.keys()),
                "successful_deliveries": len([r for r in broadcast_results if r["success"]])
            })
            
            return {
                "success": True,
                "event_id": event_id,
                "event_type": event_type,
                "broadcast_results": broadcast_results,
                "total_modules": len(broadcast_results),
                "successful_deliveries": len([r for r in broadcast_results if r["success"]]),
                "broadcast_at": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            error_msg = f"System event broadcast error: {str(e)}"
            self.identity_client.log_activity("system_event_broadcast_error", user_id, {
                "event_type": event_type,
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    def get_message_bus_stats(self, user_id: str) -> Dict[str, Any]:
        """
        Get message bus statistics and health information.
        
        Args:
            user_id: The user requesting stats
            
        Returns:
            Dict: Message bus statistics
        """
        # Verify user access
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_2"):
            return {"success": False, "error": "Insufficient tier for message bus stats"}
        
        if not self.communication_enabled or not self.message_bus:
            return {"success": False, "error": "Message bus not available"}
        
        try:
            stats = self.message_bus.get_stats()
            
            # Log stats access
            self.identity_client.log_activity("message_bus_stats_accessed", user_id, {
                "active_modules": stats.get("active_modules", []),
                "messages_sent": stats.get("messages_sent", 0),
                "messages_received": stats.get("messages_received", 0)
            })
            
            return {
                "success": True,
                "message_bus_stats": stats,
                "communication_enabled": self.communication_enabled,
                "retrieved_at": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            error_msg = f"Message bus stats error: {str(e)}"
            self.identity_client.log_activity("message_bus_stats_error", user_id, {
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    def get_system_status(self, user_id: str, include_detailed: bool = False) -> Dict[str, Any]:
        """
        Get current system status and module health.
        
        Args:
            user_id: The user requesting system status
            include_detailed: Whether to include detailed status information
            
        Returns:
            Dict: System status and module health data
        """
        # Verify user access for system status
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_2"):
            return {"success": False, "error": "Insufficient tier for system status access"}
        
        # Check consent for system monitoring
        if not self.identity_client.check_consent(user_id, "orchestration_basic"):
            return {"success": False, "error": "User consent required for system status access"}
        
        try:
            status_data = {
                "system_health": "healthy",
                "module_status": self.module_status.copy(),
                "active_workflows": len(self.active_workflows),
                "event_queue_size": len(self.event_queue),
                "timestamp": datetime.utcnow().isoformat()
            }
            
            if include_detailed and self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_3"):
                status_data.update({
                    "detailed_module_metrics": self._get_detailed_module_metrics(),
                    "workflow_details": self._get_workflow_details(),
                    "resource_utilization": self._get_resource_utilization(),
                    "performance_metrics": self._get_performance_metrics()
                })
            
            # Log status access
            self.identity_client.log_activity("system_status_accessed", user_id, {
                "include_detailed": include_detailed,
                "system_health": status_data["system_health"],
                "active_workflows": status_data["active_workflows"]
            })
            
            return {
                "success": True,
                "system_status": status_data,
                "accessed_at": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            error_msg = f"System status access error: {str(e)}"
            self.identity_client.log_activity("system_status_error", user_id, {
                "include_detailed": include_detailed,
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    def _process_coordination(self, request: Dict[str, Any], coordination_type: str) -> Dict[str, Any]:
        """Process module coordination request."""
        modules = request.get("modules", [])
        actions = request.get("actions", [])
        
        if coordination_type == "sequential":
            return self._execute_sequential_coordination(modules, actions)
        elif coordination_type == "parallel":
            return self._execute_parallel_coordination(modules, actions)
        elif coordination_type == "conditional":
            return self._execute_conditional_coordination(modules, actions, request.get("conditions", {}))
        else:
            return {"success": False, "error": f"Unknown coordination type: {coordination_type}"}
    
    def _execute_sequential_coordination(self, modules: List[str], actions: List[Dict]) -> Dict[str, Any]:
        """Execute actions sequentially across modules."""
        results = []
        total_time = 0.0
        
        for i, (module, action) in enumerate(zip(modules, actions)):
            start_time = datetime.utcnow()
            
            # Simulate module action execution
            result = {
                "module": module,
                "action": action,
                "success": True,
                "result": f"Sequential action {i+1} completed on {module}",
                "execution_order": i + 1
            }
            
            execution_time = (datetime.utcnow() - start_time).total_seconds()
            result["execution_time"] = execution_time
            total_time += execution_time
            
            results.append(result)
        
        return {
            "success": True,
            "coordination_type": "sequential",
            "results": results,
            "total_modules": len(modules),
            "execution_time": total_time
        }
    
    def _execute_parallel_coordination(self, modules: List[str], actions: List[Dict]) -> Dict[str, Any]:
        """Execute actions in parallel across modules."""
        results = []
        start_time = datetime.utcnow()
        
        # Simulate parallel execution
        for i, (module, action) in enumerate(zip(modules, actions)):
            result = {
                "module": module,
                "action": action,
                "success": True,
                "result": f"Parallel action {i+1} completed on {module}",
                "execution_order": "parallel"
            }
            results.append(result)
        
        total_time = (datetime.utcnow() - start_time).total_seconds()
        
        return {
            "success": True,
            "coordination_type": "parallel",
            "results": results,
            "total_modules": len(modules),
            "execution_time": total_time
        }
    
    def _execute_conditional_coordination(self, modules: List[str], actions: List[Dict], 
                                        conditions: Dict[str, Any]) -> Dict[str, Any]:
        """Execute actions based on conditions."""
        results = []
        total_time = 0.0
        
        for i, (module, action) in enumerate(zip(modules, actions)):
            # Check condition for this module
            condition_met = conditions.get(module, True)  # Default to True if no condition
            
            if condition_met:
                start_time = datetime.utcnow()
                result = {
                    "module": module,
                    "action": action,
                    "success": True,
                    "result": f"Conditional action {i+1} completed on {module}",
                    "condition_met": True,
                    "execution_order": len([r for r in results if r.get("condition_met")]) + 1
                }
                execution_time = (datetime.utcnow() - start_time).total_seconds()
                result["execution_time"] = execution_time
                total_time += execution_time
            else:
                result = {
                    "module": module,
                    "action": action,
                    "success": False,
                    "result": f"Condition not met for {module}",
                    "condition_met": False,
                    "execution_time": 0.0
                }
            
            results.append(result)
        
        return {
            "success": True,
            "coordination_type": "conditional",
            "results": results,
            "total_modules": len(modules),
            "executed_modules": len([r for r in results if r.get("condition_met")]),
            "execution_time": total_time
        }
    
    def _execute_workflow_steps(self, workflow_definition: Dict[str, Any], 
                               execution_mode: str) -> Dict[str, Any]:
        """Execute workflow steps."""
        steps = workflow_definition.get("steps", [])
        results = []
        total_time = 0.0
        
        for i, step in enumerate(steps):
            start_time = datetime.utcnow()
            
            step_result = {
                "step_id": step.get("id", f"step_{i+1}"),
                "step_type": step.get("type", "unknown"),
                "module": step.get("module", "unknown"),
                "success": True,
                "result": f"Workflow step {i+1} executed successfully",
                "step_order": i + 1
            }
            
            execution_time = (datetime.utcnow() - start_time).total_seconds()
            step_result["execution_time"] = execution_time
            total_time += execution_time
            
            results.append(step_result)
        
        return {
            "success": True,
            "status": "completed",
            "execution_mode": execution_mode,
            "steps_executed": len(steps),
            "step_results": results,
            "total_time": total_time
        }
    
    def _manage_module_resources(self, resource_request: Dict[str, Any], 
                               management_action: str) -> Dict[str, Any]:
        """Manage computational resources."""
        modules = resource_request.get("modules", [])
        resource_amounts = resource_request.get("amounts", {})
        
        allocated_resources = {}
        
        for module in modules:
            if management_action == "allocate":
                amount = resource_amounts.get(module, 1.0)
                allocated_resources[module] = {
                    "cpu": f"{amount * 100}%",
                    "memory": f"{amount * 1024}MB",
                    "allocated": True
                }
                # Update module load
                if module in self.module_status:
                    self.module_status[module]["load"] = min(1.0, amount)
            
            elif management_action == "deallocate":
                allocated_resources[module] = {
                    "cpu": "0%",
                    "memory": "0MB",
                    "allocated": False
                }
                # Reset module load
                if module in self.module_status:
                    self.module_status[module]["load"] = 0.0
            
            elif management_action == "optimize":
                allocated_resources[module] = {
                    "cpu": "optimized",
                    "memory": "optimized",
                    "allocated": True,
                    "optimization_applied": True
                }
        
        return {
            "success": True,
            "management_action": management_action,
            "allocated_resources": allocated_resources,
            "modules_affected": len(modules)
        }
    
    def _route_inter_module_event(self, event_data: Dict[str, Any], 
                                 routing_strategy: str) -> Dict[str, Any]:
        """Route events between modules."""
        event_type = event_data.get("type", "unknown")
        target_modules = []
        delivery_count = 0
        
        if routing_strategy == "broadcast":
            target_modules = list(self.module_status.keys())
            delivery_count = len(target_modules)
        
        elif routing_strategy == "targeted":
            target_modules = event_data.get("target_modules", [])
            delivery_count = len(target_modules)
        
        elif routing_strategy == "conditional":
            # Route based on module status and event type
            for module, status in self.module_status.items():
                if status["status"] == "available" and status["load"] < 0.8:
                    target_modules.append(module)
                    delivery_count += 1
        
        return {
            "success": True,
            "status": "delivered",
            "routing_strategy": routing_strategy,
            "event_type": event_type,
            "target_modules": target_modules,
            "delivery_count": delivery_count
        }
    
    def _get_detailed_module_metrics(self) -> Dict[str, Any]:
        """Get detailed metrics for all modules."""
        return {
            module: {
                "status": info["status"],
                "load": info["load"],
                "response_time": f"{info['load'] * 100 + 50}ms",
                "error_rate": f"{info['load'] * 2}%"
            }
            for module, info in self.module_status.items()
        }
    
    def _get_workflow_details(self) -> Dict[str, Any]:
        """Get details of active workflows."""
        return {
            "active_count": len(self.active_workflows),
            "workflows": list(self.active_workflows.keys())[:5]  # Top 5 for brevity
        }
    
    def _get_resource_utilization(self) -> Dict[str, Any]:
        """Get resource utilization across modules."""
        total_load = sum(info["load"] for info in self.module_status.values())
        avg_load = total_load / len(self.module_status) if self.module_status else 0
        
        return {
            "average_load": avg_load,
            "total_modules": len(self.module_status),
            "high_load_modules": len([m for m, info in self.module_status.items() if info["load"] > 0.7])
        }
    
    def _get_performance_metrics(self) -> Dict[str, Any]:
        """Get system performance metrics."""
        return {
            "system_uptime": "24h 30m",
            "total_requests": 1542,
            "average_response_time": "125ms",
            "success_rate": "99.7%"
        }

    # ==========================================
    # TODO #8: Performance Orchestration Methods
    # ==========================================
    
    async def start_performance_monitoring(self, user_id: str, modules: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Start performance monitoring for specified modules or all modules.
        
        Args:
            user_id: The user starting performance monitoring
            modules: Specific modules to monitor (if None, monitor all)
            
        Returns:
            Dict: Monitoring startup results
        """
        # Verify user access
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_2"):
            return {"success": False, "error": "Insufficient tier for performance monitoring"}
        
        # Check consent
        if not self.identity_client.check_consent(user_id, "performance_monitoring"):
            return {"success": False, "error": "User consent required for performance monitoring"}
        
        if not self.performance_enabled:
            return {"success": False, "error": "Performance orchestrator not available"}
        
        if self.performance_orchestrator is None:
            return {"success": False, "error": "Performance orchestrator not initialized"}
        
        try:
            # Start performance monitoring via orchestrator
            monitoring_result = await self.performance_orchestrator.start_performance_monitoring(user_id)
            
            if monitoring_result.get("success"):
                # Send performance monitoring event to all modules
                if self.message_bus:
                    await self.message_bus.send_message(Message(
                        id=f"perf_monitor_{user_id}_{int(time.time())}",
                        type=MessageType.EVENT,
                        source_module="orchestration",
                        target_module="*",  # Broadcast to all modules
                        priority=MessagePriority.NORMAL,
                        payload={
                            "event_type": "performance_monitoring_started",
                            "monitoring_id": monitoring_result.get("monitoring_id"),
                            "modules": modules or list(self.module_status.keys()),
                            "user_id": user_id
                        },
                        user_id=user_id
                    ))
                
                # Log orchestration activity
                self.identity_client.log_activity("performance_monitoring_orchestrated", user_id, {
                    "monitoring_id": monitoring_result.get("monitoring_id"),
                    "modules": modules or list(self.module_status.keys()),
                    "performance_systems_enabled": monitoring_result.get("systems_enabled", {})
                })
                
                return {
                    "success": True,
                    "monitoring_id": monitoring_result.get("monitoring_id"),
                    "modules_monitored": modules or list(self.module_status.keys()),
                    "performance_systems": monitoring_result.get("systems_enabled", {}),
                    "orchestration_features": ["cross_module_coordination", "event_broadcasting", "workflow_optimization"],
                    "started_at": monitoring_result.get("started_at")
                }
            else:
                return monitoring_result
                
        except Exception as e:
            error_msg = f"Performance monitoring orchestration error: {str(e)}"
            self.identity_client.log_activity("performance_monitoring_orchestration_error", user_id, {
                "error": error_msg,
                "modules": modules
            })
            return {"success": False, "error": error_msg}
    
    async def optimize_system_performance(self, user_id: str, strategy: str = "adaptive",
                                        modules: Optional[List[str]] = None,
                                        workflow_context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Orchestrate system-wide performance optimization with workflow awareness.
        
        Args:
            user_id: The user requesting optimization
            strategy: Optimization strategy (adaptive, real_time, batch, etc.)
            modules: Specific modules to optimize
            workflow_context: Current workflow context for optimization decisions
            
        Returns:
            Dict: Optimization orchestration results
        """
        # Verify user access
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_3"):
            return {"success": False, "error": "Insufficient tier for performance optimization"}
        
        # Check consent
        if not self.identity_client.check_consent(user_id, "performance_optimization"):
            return {"success": False, "error": "User consent required for performance optimization"}
        
        if not self.performance_enabled:
            return {"success": False, "error": "Performance orchestrator not available"}
        
        if self.performance_orchestrator is None:
            return {"success": False, "error": "Performance orchestrator not initialized"}
        
        try:
            # Prepare workflow-aware optimization
            target_modules = modules or list(self.module_status.keys())
            
            # Check module status before optimization
            module_health = {}
            for module in target_modules:
                if module in self.module_status:
                    module_health[module] = self.module_status[module].copy()
            
            # Execute performance optimization
            optimization_result = await self.performance_orchestrator.optimize_performance(
                user_id, strategy, target_modules
            )
            
            if optimization_result.get("success"):
                # Broadcast optimization event to affected modules
                if self.message_bus:
                    await self.message_bus.send_message(Message(
                        id=f"perf_optimize_{user_id}_{int(time.time())}",
                        type=MessageType.EVENT,
                        source_module="orchestration",
                        target_module="*",
                        priority=MessagePriority.HIGH,
                        payload={
                            "event_type": "performance_optimization_completed",
                            "optimization_id": optimization_result.get("optimization_id"),
                            "strategy": strategy,
                            "modules_optimized": target_modules,
                            "improvements": optimization_result.get("improvements", {}),
                            "workflow_context": workflow_context,
                            "user_id": user_id
                        },
                        user_id=user_id
                    ))
                
                # Update module status based on optimization
                self._update_module_status_post_optimization(target_modules, optimization_result)
                
                # Log orchestration activity
                self.identity_client.log_activity("performance_optimization_orchestrated", user_id, {
                    "optimization_id": optimization_result.get("optimization_id"),
                    "strategy": strategy,
                    "modules_optimized": target_modules,
                    "overall_improvement": optimization_result.get("improvements", {}).get("overall_score", 0),
                    "workflow_context": workflow_context is not None
                })
                
                return {
                    "success": True,
                    "optimization_id": optimization_result.get("optimization_id"),
                    "strategy": strategy,
                    "modules_optimized": target_modules,
                    "module_health_before": module_health,
                    "performance_improvements": optimization_result.get("improvements", {}),
                    "orchestration_enhancements": [
                        "cross_module_coordination",
                        "workflow_aware_optimization",
                        "unified_performance_tracking"
                    ],
                    "compliance_maintained": optimization_result.get("compliance_maintained", True),
                    "execution_time_ms": optimization_result.get("execution_time_ms", 0),
                    "optimized_at": optimization_result.get("optimized_at")
                }
            else:
                return optimization_result
                
        except Exception as e:
            error_msg = f"Performance optimization orchestration error: {str(e)}"
            self.identity_client.log_activity("performance_optimization_orchestration_error", user_id, {
                "strategy": strategy,
                "modules": modules,
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    async def get_orchestrated_performance_status(self, user_id: str, include_module_details: bool = False) -> Dict[str, Any]:
        """
        Get comprehensive performance status across all orchestrated modules.
        
        Args:
            user_id: The user requesting status
            include_module_details: Whether to include detailed module-specific metrics
            
        Returns:
            Dict: Orchestrated performance status
        """
        # Verify user access
        if not self.identity_client.verify_user_access(user_id, "LAMBDA_TIER_2"):
            return {"success": False, "error": "Insufficient tier for performance status"}
        
        if not self.performance_enabled:
            return {"success": False, "error": "Performance orchestrator not available"}
        
        if self.performance_orchestrator is None:
            return {"success": False, "error": "Performance orchestrator not initialized"}
        
        try:
            # Get performance status from orchestrator
            performance_status = await self.performance_orchestrator.get_performance_status(
                user_id, include_detailed=include_module_details
            )
            
            if performance_status.get("success"):
                # Add orchestration-specific information
                orchestration_info = {
                    "orchestration_layer": {
                        "active_workflows": len(self.active_workflows),
                        "module_coordination_status": self.module_status.copy(),
                        "communication_enabled": self.communication_enabled,
                        "performance_integration": self.performance_enabled,
                        "message_queue_length": len(self.event_queue)
                    },
                    "cross_module_health": self._assess_cross_module_health(),
                    "workflow_performance_impact": self._analyze_workflow_performance_impact()
                }
                
                # Log status access
                self.identity_client.log_activity("orchestrated_performance_status_accessed", user_id, {
                    "performance_status": performance_status.get("performance_status"),
                    "overall_score": performance_status.get("overall_score", 0),
                    "active_workflows": len(self.active_workflows),
                    "include_module_details": include_module_details
                })
                
                # Merge performance status with orchestration info
                result = performance_status.copy()
                result.update(orchestration_info)
                result["orchestration_enhanced"] = True
                
                return result
            else:
                return performance_status
                
        except Exception as e:
            error_msg = f"Orchestrated performance status error: {str(e)}"
            self.identity_client.log_activity("orchestrated_performance_status_error", user_id, {
                "error": error_msg
            })
            return {"success": False, "error": error_msg}
    
    def _update_module_status_post_optimization(self, modules: List[str], optimization_result: Dict[str, Any]) -> None:
        """Update module status based on optimization results."""
        improvements = optimization_result.get("improvements", {})
        
        # Simulate load reduction based on optimization improvements
        load_reduction_factor = max(0.1, min(0.3, improvements.get("overall_score", 0) / 100))
        
        for module in modules:
            if module in self.module_status:
                current_load = self.module_status[module]["load"]
                new_load = max(0.0, current_load * (1 - load_reduction_factor))
                self.module_status[module]["load"] = new_load
                self.module_status[module]["last_optimized"] = datetime.utcnow().isoformat()
    
    def _assess_cross_module_health(self) -> Dict[str, Any]:
        """Assess health of cross-module communication and coordination."""
        total_modules = len(self.module_status)
        available_modules = len([m for m in self.module_status.values() if m["status"] == "available"])
        average_load = sum(m["load"] for m in self.module_status.values()) / total_modules if total_modules > 0 else 0
        
        health_score = (available_modules / total_modules) * 100 if total_modules > 0 else 0
        load_score = max(0, 100 - (average_load * 100))
        
        return {
            "overall_health_score": (health_score + load_score) / 2,
            "available_modules": available_modules,
            "total_modules": total_modules,
            "average_load": average_load,
            "communication_status": "enabled" if self.communication_enabled else "disabled"
        }
    
    def _analyze_workflow_performance_impact(self) -> Dict[str, Any]:
        """Analyze how current workflows impact system performance."""
        active_count = len(self.active_workflows)
        
        if active_count == 0:
            return {
                "impact_level": "none",
                "active_workflows": 0,
                "estimated_performance_impact": 0,
                "recommendations": ["No active workflows - optimal performance expected"]
            }
        
        # Estimate performance impact based on workflow complexity
        impact_score = min(100, active_count * 15)  # Each workflow ~15% impact
        
        if impact_score < 25:
            impact_level = "low"
            recommendations = ["Current workflow load is manageable"]
        elif impact_score < 50:
            impact_level = "moderate"
            recommendations = ["Consider workflow optimization", "Monitor resource usage"]
        elif impact_score < 75:
            impact_level = "high"
            recommendations = ["Optimize or pause non-critical workflows", "Increase resource allocation"]
        else:
            impact_level = "critical"
            recommendations = ["Emergency workflow optimization needed", "Consider system scaling"]
        
        return {
            "impact_level": impact_level,
            "active_workflows": active_count,
            "estimated_performance_impact": impact_score,
            "recommendations": recommendations
        }


# Module API functions for easy import
def coordinate_modules(user_id: str, coordination_request: Dict[str, Any], 
                      coordination_type: str = "sequential") -> Dict[str, Any]:
    """Simplified API for module coordination."""
    service = OrchestrationService()
    return service.coordinate_modules(user_id, coordination_request, coordination_type)

def execute_workflow(user_id: str, workflow_definition: Dict[str, Any]) -> Dict[str, Any]:
    """Simplified API for workflow execution."""
    service = OrchestrationService()
    return service.execute_workflow(user_id, workflow_definition)

def get_system_status(user_id: str) -> Dict[str, Any]:
    """Simplified API for system status."""
    service = OrchestrationService()
    return service.get_system_status(user_id)

async def send_module_message(user_id: str, source: str, target: str, 
                             message_type: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    """Simplified API for inter-module messaging."""
    service = OrchestrationService()
    await service.start_orchestration()
    return await service.send_inter_module_message(user_id, source, target, message_type, payload)


# ==========================================
# Enhanced Simplified API Functions (TODO #8)
# ==========================================

async def start_monitoring(user_id: str, modules: Optional[List[str]] = None) -> Dict[str, Any]:
    """Simplified API for starting orchestrated performance monitoring."""
    service = OrchestrationService()
    await service.start_orchestration()
    return await service.start_performance_monitoring(user_id, modules)

async def optimize_performance(user_id: str, strategy: str = "adaptive", 
                             modules: Optional[List[str]] = None) -> Dict[str, Any]:
    """Simplified API for orchestrated performance optimization."""
    service = OrchestrationService()
    await service.start_orchestration()
    return await service.optimize_system_performance(user_id, strategy, modules)

async def get_performance_status(user_id: str, detailed: bool = False) -> Dict[str, Any]:
    """Simplified API for orchestrated performance status."""
    service = OrchestrationService()
    await service.start_orchestration()
    return await service.get_orchestrated_performance_status(user_id, detailed)


async def broadcast_event(user_id: str, event_type: str, event_data: Dict[str, Any]) -> Dict[str, Any]:
    """Simplified API for system event broadcasting."""
    service = OrchestrationService()
    await service.start_orchestration() 
    return await service.broadcast_system_event(user_id, event_type, event_data)


if __name__ == "__main__":
    # Example usage
    import asyncio
    
    async def main():
        orchestration = OrchestrationService()
        await orchestration.start_orchestration()
        
        test_user = "test_lambda_user_001"
        
        # Test module coordination
        coordination_result = orchestration.coordinate_modules(
            test_user,
            {
                "modules": ["ethics", "memory", "creativity"],
                "actions": [
                    {"type": "assess", "target": "user_action"},
                    {"type": "store", "target": "assessment_result"},
                    {"type": "generate", "target": "creative_response"}
                ]
            },
            "sequential"
        )
        print(f"Module coordination: {coordination_result.get('success', False)}")
        
        # Test inter-module messaging
        if orchestration.communication_enabled:
            message_result = await orchestration.send_inter_module_message(
                test_user, "orchestration", "memory", "command",
                {"action": "store", "data": "test coordination result"}
            )
            print(f"Inter-module message: {message_result.get('success', False)}")
            
            # Test system event broadcast
            broadcast_result = await orchestration.broadcast_system_event(
                test_user, "system_test", {"message": "Testing cross-module communication"}
            )
            print(f"System broadcast: {broadcast_result.get('success', False)}")
            
            # Get message bus stats
            stats_result = orchestration.get_message_bus_stats(test_user)
            print(f"Message bus stats: {stats_result.get('success', False)}")
        
        # Test workflow execution
        workflow_result = orchestration.execute_workflow(
            test_user,
            {
                "steps": [
                    {"id": "step1", "type": "analysis", "module": "consciousness"},
                    {"id": "step2", "type": "learning", "module": "learning"},
                    {"id": "step3", "type": "synthesis", "module": "creativity"}
                ]
            }
        )
        print(f"Workflow execution: {workflow_result.get('success', False)}")
        
        # Test system status
        status_result = orchestration.get_system_status(test_user, True)
        print(f"System status: {status_result.get('success', False)}")
    
    asyncio.run(main())
