#!/usr/bin/env python3"""Security Tests for AGI Consolidation Repository===============================================Tests for security fixes and configurations"""import osimport sysimport hashlibimport subprocessimport tempfilefrom pathlib import Path# Add the repo root to path for importsrepo_root = Path(__file__).parentsys.path.insert(0, str(repo_root))# Try to import pytest for advanced testingtry:    import pytest    PYTEST_AVAILABLE = True        try:        from security_config import (            get_github_token, validate_token_format, sanitize_filename,            validate_url, get_security_headers, REQUIRED_SCOPES        )        SECURITY_CONFIG_AVAILABLE = True    except ImportError:        SECURITY_CONFIG_AVAILABLE = False        except ImportError:    PYTEST_AVAILABLE = False    SECURITY_CONFIG_AVAILABLE = False# Advanced pytest-based tests (only if pytest is available)if PYTEST_AVAILABLE and SECURITY_CONFIG_AVAILABLE:        class TestSecurityConfig:        """Test security configuration functions"""                def test_validate_token_format_valid(self):            """Test valid token formats"""            valid_tokens = [                "ghp_" + "x" * 36,                "gho_" + "x" * 36,                "ghu_" + "x" * 36,                "ghs_" + "x" * 36,                "ghr_" + "x" * 36,            ]                        for token in valid_tokens:                valid, message = validate_token_format(token)                assert valid, f"Token {token[:10]}... should be valid: {message}"                def test_validate_token_format_invalid(self):            """Test invalid token formats"""            invalid_tokens = [                "",                "invalid_token",                "ghp_short",                "ghp_" + "x" * 35,  # Too short                "ghp_" + "x" * 37,  # Too long                "xyz_" + "x" * 36,  # Invalid prefix            ]                        for token in invalid_tokens:                valid, message = validate_token_format(token)                assert not valid, f"Token {token[:10]}... should be invalid"                def test_sanitize_filename(self):            """Test filename sanitization"""            test_cases = [                ("normal_file.txt", "normal_file.txt"),                ("../../../etc/passwd", "etc_passwd"),                ("file with spaces.txt", "file_with_spaces.txt"),                ("file/with/slashes.txt", "file_with_slashes.txt"),                ("file\\with\\backslashes.txt", "file_with_backslashes.txt"),                ("file:with:colons.txt", "file_with_colons.txt"),                ("file|with|pipes.txt", "file_with_pipes.txt"),                ("file\"with\"quotes.txt", "file_with_quotes.txt"),            ]                        for input_name, expected in test_cases:                result = sanitize_filename(input_name)                assert result == expected, f"Expected {expected}, got {result}"                def test_validate_url(self):            """Test URL validation"""            valid_urls = [                "https://api.github.com/user",                "https://github.com/user/repo",                "http://localhost:8080/test",            ]                        invalid_urls = [                "javascript:alert('xss')",                "file:///etc/passwd",                "ftp://example.com",                "not_a_url",                "",            ]                        for url in valid_urls:                valid, message = validate_url(url)                assert valid, f"URL {url} should be valid: {message}"                        for url in invalid_urls:                valid, message = validate_url(url)                assert not valid, f"URL {url} should be invalid"                def test_get_security_headers(self):            """Test security headers generation"""            headers = get_security_headers()                        required_headers = [                'User-Agent',                'Accept',                'X-GitHub-Api-Version',            ]                        for header in required_headers:                assert header in headers, f"Missing required header: {header}"                        # Test with custom token            token = "ghp_test_token_123456789012345678901234567890"            headers_with_token = get_security_headers(token)            assert 'Authorization' in headers_with_token            assert headers_with_token['Authorization'] == f'token {token}'# Basic security tests (always available)def test_no_hardcoded_tokens():    """Test that no hardcoded GitHub tokens exist in the codebase"""    print("ğŸ” Testing for hardcoded GitHub tokens...")        # Common GitHub token patterns    token_patterns = [        b'ghp_',  # Personal access tokens        b'gho_',  # OAuth tokens        b'ghu_',  # User tokens        b'ghs_',  # Server-to-server tokens        b'ghr_',  # Refresh tokens    ]        # Files to check    files_to_check = []    for root, dirs, files in os.walk('.'):        # Skip hidden directories and cache        dirs[:] = [d for d in dirs if not d.startswith('.') and d != '__pycache__']                for file in files:            if file.endswith(('.py', '.md', '.txt', '.yml', '.yaml', '.json')):                files_to_check.append(os.path.join(root, file))        found_tokens = []    for file_path in files_to_check:        try:            with open(file_path, 'rb') as f:                content = f.read()                for pattern in token_patterns:                    if pattern in content:                        # Check if it's a real token (not in comments or examples)                        lines = content.decode('utf-8', errors='ignore').split('\n')                        for i, line in enumerate(lines):                            if pattern.decode() in line:                                # Skip obvious examples and comments                                if not any(skip in line.lower() for skip in ['example', 'placeholder', 'your_token', 'test_token']):                                    found_tokens.append(f"{file_path}:{i+1}: {line.strip()}")        except Exception as e:            print(f"Warning: Could not read {file_path}: {e}")        if found_tokens:        print("âŒ Found potential hardcoded tokens:")        for token in found_tokens:            print(f"  {token}")        return False    else:        print("âœ… No hardcoded tokens found")        return Truedef test_environment_variable_usage():    """Test that environment variables are properly used for sensitive data"""    print("ğŸ” Testing environment variable usage...")        # Check that critical files use environment variables    critical_files = [        'lukhas/identity/backend/verifold/yubi_seeder.py',        'lukhas/identity/backend/app/emailer.py',        'temporary-scripts/check_token_privileges.py',        'temporary-scripts/deploy_security_policy.py',        'temporary-scripts/setup_main_repo.py',        'temporary-scripts/setup_webhooks.py',    ]        env_var_usage = []    for file_path in critical_files:        if os.path.exists(file_path):            try:                with open(file_path, 'r', encoding='utf-8') as f:                    content = f.read()                    if 'os.environ' in content or 'os.getenv' in content:                        env_var_usage.append(file_path)            except Exception as e:                print(f"Warning: Could not read {file_path}: {e}")        if env_var_usage:        print("âœ… Found environment variable usage in:")        for file_path in env_var_usage:            print(f"  {file_path}")        return True    else:        print("âŒ No environment variable usage found in critical files")        return Falsedef test_secure_hashing():    """Test that secure hashing is used where appropriate"""    print("ğŸ” Testing secure hashing usage...")        # Check for insecure hashing methods    insecure_patterns = [b'md5', b'sha1']    secure_patterns = [b'sha256', b'sha512', b'bcrypt', b'scrypt']        files_to_check = []    for root, dirs, files in os.walk('.'):        dirs[:] = [d for d in dirs if not d.startswith('.') and d != '__pycache__']        for file in files:            if file.endswith('.py'):                files_to_check.append(os.path.join(root, file))        insecure_found = []    secure_found = []        for file_path in files_to_check:        try:            with open(file_path, 'rb') as f:                content = f.read()                for pattern in insecure_patterns:                    if pattern in content:                        insecure_found.append(file_path)                for pattern in secure_patterns:                    if pattern in content:                        secure_found.append(file_path)        except Exception as e:            print(f"Warning: Could not read {file_path}: {e}")        if insecure_found:        print("âš ï¸  Found insecure hashing in:")        for file_path in insecure_found:            print(f"  {file_path}")        if secure_found:        print("âœ… Found secure hashing in:")        for file_path in secure_found:            print(f"  {file_path}")        return True    else:        print("âœ… No hashing methods found (neutral result)")        return Truedef test_gitignore_security():    """Test that sensitive files are properly ignored"""    print("ğŸ” Testing .gitignore security...")        gitignore_path = '.gitignore'    if not os.path.exists(gitignore_path):        print("âŒ No .gitignore file found")        return False        with open(gitignore_path, 'r') as f:        gitignore_content = f.read()        # Check for important patterns    important_patterns = [        '*.env',        '.env',        'secrets',        '*.key',        '*.pem',        '__pycache__',        '*.pyc',    ]        missing_patterns = []    for pattern in important_patterns:        if pattern not in gitignore_content:            missing_patterns.append(pattern)        if missing_patterns:        print("âš ï¸  Missing .gitignore patterns:")        for pattern in missing_patterns:            print(f"  {pattern}")        return False    else:        print("âœ… .gitignore has good security patterns")        return Truedef test_lambda_bot_token_security():    """Test that Lambda bot token is properly secured"""    print("ğŸ” Testing Lambda bot token security...")        lambda_token_file = '.lambda_bot_token'    if os.path.exists(lambda_token_file):        try:            with open(lambda_token_file, 'r') as f:                content = f.read().strip()                if content and len(content) > 10:                    print("âš ï¸  Lambda bot token file contains data - ensure it's properly secured")                    return False                else:                    print("âœ… Lambda bot token file is empty or placeholder")                    return True        except Exception as e:            print(f"âŒ Could not read lambda bot token file: {e}")            return False    else:        print("âœ… No lambda bot token file found")        return Truedef main():    """Run all security tests"""    print("ğŸ›¡ï¸  AGI Consolidation Repository Security Test Suite")    print("=" * 60)        tests = [        ("No Hardcoded Tokens", test_no_hardcoded_tokens),        ("Environment Variables", test_environment_variable_usage),        ("Secure Hashing", test_secure_hashing),        ("GitIgnore Security", test_gitignore_security),        ("Lambda Bot Token", test_lambda_bot_token_security)    ]        results = []    for test_name, test_func in tests:        try:            result = test_func()            results.append((test_name, result))        except Exception as e:            print(f"âŒ {test_name} failed with exception: {e}")            results.append((test_name, False))        print("\n" + "=" * 50)    print("ğŸ“Š TEST RESULTS SUMMARY")    print("=" * 50)        passed = 0    total = len(results)        for test_name, result in results:        status = "âœ… PASS" if result else "âŒ FAIL"        print(f"{status} {test_name}")        if result:            passed += 1        print(f"\nğŸ“ˆ Overall: {passed}/{total} tests passed")        if passed == total:        print("ğŸ‰ All security tests passed!")        return 0    else:        print("âš ï¸  Some security tests failed - review needed")        return 1if __name__ == "__main__":    if PYTEST_AVAILABLE:        # Run pytest tests if available        pytest.main([__file__, "-v"])    else:        # Run basic tests        sys.exit(main())
