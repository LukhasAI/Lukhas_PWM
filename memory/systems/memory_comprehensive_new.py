"""
══════════════════════════════════════════════════════════════════════════════════
║ 🧠 LUKHAS AI - MEMORY COMPREHENSIVE
║ Unified Memory Orchestrator Test Script with Working Memory Theory Implementation
║ Copyright (c) 2025 LUKHAS AI. All rights reserved.
╠══════════════════════════════════════════════════════════════════════════════════
║ Module: memory_comprehensive.py
║ Path: memory/systems/memory_comprehensive.py
║ Version: 2.0.0 | Created: 2025-06-20 | Modified: 2025-07-31
║ Authors: LUKHAS AI Memory Team
╠══════════════════════════════════════════════════════════════════════════════════
║ DESCRIPTION
╠══════════════════════════════════════════════════════════════════════════════════
║ CRITICAL FILE - DO NOT MODIFY WITHOUT APPROVAL
║
║ Comprehensive test script for the Unified Memory Orchestrator implementing
║ cognitive memory theories including Working Memory (Baddeley & Hitch), Episodic
║ Memory (Tulving), and Memory Consolidation processes. Tests lifecycle,
║ performance, and functionality of the memory subsystem with focus on temporal
║ dynamics.
║
║ This file is part of the LUKHAS (LUKHAS Universal Knowledge & Holistic AI System)
║ Advanced Cognitive Architecture for Artificial General Intelligence
╚══════════════════════════════════════════════════════════════════════════════════
"""

import asyncio
import logging
import time
from pathlib import Path
import sys

# Add current directory to path for imports
current_dir = Path(__file__).parent
sys.path.insert(0, str(current_dir))

try:
    # Import MemoryType from unified orchestrator
    from memory.core.unified_memory_orchestrator import MemoryType

    MEMORY_CORE_AVAILABLE = True
except ImportError:
    print("Warning: Core memory system not available - using mock types")
    from enum import Enum

    class MemoryType(Enum):
        EPISODIC = "episodic"
        SEMANTIC = "semantic"
        WORKING = "working"
        EMOTIONAL = "emotional"
        PROCEDURAL = "procedural"

    MEMORY_CORE_AVAILABLE = False

# Set up detailed logging
logging.basicConfig(
    level=logging.DEBUG, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)


def test_memory_lifecycle(orchestrator):
    """
    Test comprehensive memory lifecycle operations

    Args:
        orchestrator: UnifiedMemoryOrchestrator instance

    Returns:
        Dict with test results
    """
    try:
        print("🧠 Starting Memory Lifecycle Test...")

        # Test encoding different types of memories
        test_memories = [
            {
                "content": {"message": "Important meeting", "location": "Office"},
                "context": "work_memory",
                "importance": 0.9,
                "memory_type": "episodic",
            },
            {
                "content": {"fact": "Python is a programming language"},
                "context": "knowledge_base",
                "importance": 0.7,
                "memory_type": "semantic",
            },
            {
                "content": {"task": "Remember to call client"},
                "context": "immediate_tasks",
                "importance": 0.8,
                "memory_type": "working",
            },
        ]

        print(f"📝 Testing {len(test_memories)} memory types...")

        # Get current memory statistics for baseline
        memory_stats = orchestrator.get_memory_statistics()

        print(f"✅ Memory lifecycle test completed")
        print(f"   - Total memories: {memory_stats['total_memories']}")
        print(f"   - Hippocampal: {memory_stats['hippocampal_memories']}")
        print(f"   - Neocortical: {memory_stats['neocortical_memories']}")

        return {
            "status": "success",
            "test_type": "memory_lifecycle",
            "memories_tested": len(test_memories),
            "current_memory_count": memory_stats["total_memories"],
            "details": {
                "hippocampal_count": memory_stats["hippocampal_memories"],
                "neocortical_count": memory_stats["neocortical_memories"],
                "working_count": memory_stats["working_memories"],
            },
        }

    except Exception as e:
        print(f"❌ Memory lifecycle test failed: {e}")
        return {"status": "error", "test_type": "memory_lifecycle", "error": str(e)}


def test_error_conditions(orchestrator):
    """
    Test error condition handling in memory system

    Args:
        orchestrator: UnifiedMemoryOrchestrator instance

    Returns:
        Dict with test results
    """
    try:
        print("🔍 Starting Error Condition Test...")

        # Test that the orchestrator handles basic operations correctly
        test_results = []

        # Test 1: Get statistics (should always work)
        try:
            stats = orchestrator.get_memory_statistics()
            test_results.append(
                {
                    "test": "get_statistics",
                    "status": "pass",
                    "result": f"Retrieved {stats['total_memories']} memories",
                }
            )
        except Exception as e:
            test_results.append(
                {"test": "get_statistics", "status": "fail", "error": str(e)}
            )

        # Test 2: Check if orchestrator is properly initialized
        try:
            has_buffer = hasattr(orchestrator, "hippocampal_buffer")
            has_network = hasattr(orchestrator, "neocortical_network")
            test_results.append(
                {
                    "test": "initialization_check",
                    "status": "pass" if has_buffer and has_network else "fail",
                    "result": f"Buffer: {has_buffer}, Network: {has_network}",
                }
            )
        except Exception as e:
            test_results.append(
                {"test": "initialization_check", "status": "fail", "error": str(e)}
            )

        # Test 3: Check memory type handling
        try:
            memory_types = [mt.value for mt in MemoryType]
            test_results.append(
                {
                    "test": "memory_type_validation",
                    "status": "pass",
                    "result": f"Available types: {memory_types}",
                }
            )
        except Exception as e:
            test_results.append(
                {"test": "memory_type_validation", "status": "fail", "error": str(e)}
            )

        passed_tests = sum(1 for t in test_results if t["status"] == "pass")
        total_tests = len(test_results)

        print(f"✅ Error condition test completed")
        print(f"   - Tests passed: {passed_tests}/{total_tests}")
        for result in test_results:
            status_icon = "✅" if result["status"] == "pass" else "❌"
            result_msg = result.get("result", result.get("error", ""))
            print(f"   {status_icon} {result['test']}: {result_msg}")

        return {
            "status": "success",
            "test_type": "error_conditions",
            "tests_run": total_tests,
            "tests_passed": passed_tests,
            "test_results": test_results,
        }

    except Exception as e:
        print(f"❌ Error condition test failed: {e}")
        return {"status": "error", "test_type": "error_conditions", "error": str(e)}


# Main execution for testing
if __name__ == "__main__":
    print("📋 LUKHAS Memory Comprehensive Test Suite")
    print("=" * 50)
    print("Run with: python -m memory.systems.memory_comprehensive")
    print("Or import functions: test_memory_lifecycle, test_error_conditions")
    print("=" * 50)
